Core Groovy Tasks
=================

* closure methods on Node
	
* more tests of field and property initialisers

* test closure with no argument, once bob's done the parser. both
    foo = { someMethod() }
    foo2 = {| someMethod() }
    foo.call()

* refactor the MetaClass to use an Object[] rather than Object for arguments?

* have some kinda way to do this

	MethodProxy proxy = metaClass.getMethod("name", List arguments)
	if (proxy != null) {
		proxy.call(instance, arguments);
	}
	else {
		// invoke on delegate
		InvokeHelper.invokeMethod(delegate, name, arguments)
	}	

	so rather than just doing 'hasMethod' or 'understandsMethod' we can return
	a Closure or MethodProxy or something or null if a method is not understood

* allow closures to have a delegate object, so that when they are used in a 
	tree build kind of way, the methods can be forwarded to a top level owner.
	
	e.g.
	
	someBuilder.root {
		child {
			grandChild()
		}
	}
	
	the child and grandChild methods could be invoked on someBuilder if the builder decided to 
	register itself as the delegate on the Closure. The delegate would be, by default, the
	outer class instance.
	

* integer.times() method?

* validator for things like - undeclared variables

* test use of constructors

* closures need to be able to access properties and methods of outer class

* closures - handle passing in of variables from outer scope?

* remove log4j dependency

* constructors with map / tuple expressions, named parameter calling
 
* default values for parameters

* test try / catch with multiple exception types

* change to use == for equals?

* test [] on lists & maps?

* constructors - test use of super()

* test use of method calls: foo() this.foo() class.foo() for local, inherited & global methods

* += and -= operators

* ++ and --

* this.foo should declare a local field?
	if so this could cause confusion with property access?
	maybe some new syntax like @foo or this->foo = x;
	

* should we implement + and - for collections and maps?

	l = [1, 2] + [3, 4];
	assert l := [1, 2, 3, 4];
	
* should we implement get(String) on collection to implement nested property fetching?

* while / do - while statements

* test use of overloaded setter methods & use of property notation
  so that the use of properties within a class should use setteres / getters.

* test the use of PropertyExpression
	a.b = c.d
	
* support static new() method for constructors

* finish expression support in classgen

* support metadata (like JDK 1.5) as well as tree based metadata...

Ê Ê window = @layout {
Ê Ê Ê Ê frame text="My Window" size=[300,300] {
Ê Ê Ê Ê Ê Ê label text="Save changes?" bounds=[10,10,290,30]
Ê Ê Ê Ê Ê Ê panel bounds=[10,40,290,290] {
Ê Ê Ê Ê Ê Ê Ê Ê button text="OK" action={ save() ; window.close() }
Ê Ê Ê Ê Ê Ê Ê Ê button text="Cancel" action={ Êwindow.close() }
Ê Ê Ê Ê Ê Ê }
Ê Ê Ê Ê }
Ê Ê };

* refactor ast into expression, statement packages

* maybe split up ClassGenerator - do code gen & class gen separately

* create MetaClass for JMX - so we can treat JMX objects as if they're normal objects

* mixin support...

	SomeClass.addMixin(Foo);
	
	MetaClass.addInterceptor( new Interceptor() {
		filter(method) {
			return method.isPublic();
		}
		invoke(method, args) {
			// do something
			method.invoke(args);
		}
	});

	* allow meta classes to be added dynamically using closure syntax?
	e.g. Map?
	
	

ECLIPSE WORK
============

We really need to start work on the Eclipse plugin. I *so* want neat Eclipse support for groovy

* Run as JUnit support for Groovy! 

* Refactoring support for Groovy and tie it into the Java refactoring

* a WYSIWYG editor for Groovy. Though right now I've found that the Java Scrapbook editor is fine


JUNIT WORK
==========

* patch GroovyTestCase so that methods which return Object are included in the test. This avoids us having to
specify void for method return types.This requires a clever static method when we generate the
	bytecode which can instantiate a special kind of TestSuite
	unless there's another way?

OTHER STUFF
===========


OPTIMISATIONS
=============
* method invocations - if instanceof DynamicMethodInvoke
then generate bytecode

foo.invokeMethod(method, args);

* could code generate the MetaClass with very efficient dynamic dispatch
	e.g. could switch() on the method name & then use real method invocation
	on the method instance


L
MARKUP
======

Have Groovy -> SAX thingy for others to use as XML language?


THINGS TO PONDER
================

* should we follow ruby rules where the last statement, if its an expression, then its an explicit return.

e.g.

foo() {
   2 * x
}

would implicitly mean

foo() {
   return 2 * x
}
