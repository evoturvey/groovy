Things to Test
==============

* document the script stuff and use of Groovy script!

* test compiler errors when
	- unknown class
		in new expression
		in exception catching
		in general class expression
	- unknown variable

* tidy up javadoc

* test date range using Range object

* test max, min, sort with closure comparator
	- min/max/sort to allow closures for comparators
		foo.max { a, b | a.length <=> b.length }
	- ClosureComparator
			
* test map properties..

	m = [:]
	m.foo = ...
	assert m.foo == ...
	
* test while, do while

* test use of GroovyClassLoader with importing of other classes (e.g. java.lang.*)

* test Button(actionPerformed:{event| event.println() }

* remove dependency on asm-util on the compiler

	
Core Groovy Tasks
=================

* GroovyServlet - serves up *.groovy files

* new GroovyMethods	to be added
	- Object.getMetaClass()
	- Object.eachProperty
	- Object.eachPropertyName { object.getProperty(it) }
	- Object.setProperties(foo:'abc', x:123)
	
	- removeIf { x | x > 0 }
	- List.first, List.last, pop
	- List.eachWithindex { item, idx | ... }
	- reverseEach { ... }
	- Map.eachKey, eachValue
	- Map.index, Map.indexes
	- Object.display (rather than toConsoleOutput)
	- grep(pattern)  { closure }
		where pattern = range / regexp
	- eval("....")
	- gets
	- load(...)
	- File.eachByte
	- configure method on beans?
		bean.setProperties(name:'James', location:'London')
	- some kind of Regexp iterator of strings like Ruby's scan
	- maybe support Pythons' zip and reduce functions?

* add support for special variables
	class
	super (base class)
		
* BeanBuilder - builder which creates a tree of beans
	builder.bean(class:SomeClass, x:123, b:'hello') {
		nestedProperty(a:123)
		nestedProperty2(class:DerivedClass, b:43)
	}
	using adder method as well as setter methods

* MBeanBuilder?
	builder.mlet {
		mbean(class:SomeClass) {
			someAttribute(value)
		}
		mbean(class:SomeClass, someAttribute:value) {
			operation(1, 2)
		}
	}

* GroovyMBean - allow iteration through properties somehow

* allow constructors to have optional trailing closure...
	new JFrame() { text = 'hello'; size = [1, 2] }
			
* closures - handle passing in of variables from outer scope?	
	use a Holder object for all local variables and pass holder
	into the closure
	
* support instanceof operator
			
* Switch statement to use matches to handle classes, ranges, regexp etc		
	- matches(object) for Range or Regexp or Class

* looks like a bug on generated methods, should use param name over any field name
	- also it looks like there's various unnecessary stuff (creation of tuples) when invoking
	methods
	
* bug - x = methodName fails, but x = this.methodName works
	- need to turn variableExpressions into property expressions
	- if no local variable in scope

* groovy thread...
	foo = new GroovyThread(args) { closure }
	
* <=> for compareTo()

* << for list append and for output to streams
	maybe other optional IO methods like gets?

* DocTool 
	- use wiki parser and allow embedded test cases, documentation, examples
	
	[Test
		>>> a = [1, 2, 3]
		[1, 2, 3]
		>>> x = ...
		
	]
	
	or
	
	[Test some operation thingy
		x = ...
		assert x.whatnot == 7
	]

	
* something like Ruby's Binding & eval APIs		
	
* is there a better way to add listeners in Groovy. e.g. how to remove added listeners

	listener = bean.property + { some closure }
	bean.property - listener
	
* .@ support on W3C DOM trees...

* article
	- basics of groovy
	- groovy swing

* doc to write
	- using beans + listeners
	- expression language

* closure on construction of beans?
	new JTable() {....}
		invokes the closure with the new object as delegate for setting properties etc

* support -ve indices on subscript operator

* foo[1, 2] versus foo[1..2] etc

* MetaClass -> add getPropertyDescriptor which has methods
	- get(), set(), type(), cardinality() etc
	
	could use naming conventions to detect cardinality - e.g. addFoo(), getFoos()
	
	
* generate property change listener stuff on properties

* test identity -> hashCode + equals methods

* support for property converters, based on type

* Map.get(key, defaultValue)
* Map.setDefault(key, defaultValue) for things like
	map.setDefault(key, []).add(newValue)
	
	to ensure the map has a list of things

* maybe add python's * and ** for any number of args or maps in method decl

* use *args in method invocation to expand a list as argument values	
	
* access to local variables from inside a closure

* switch statements
	switch(value) {
		case "hello":
		case 0..12:
		case /foo|bar/:
		case a, b, c
		case FooClass:
	}		

* implement break, continue and maybe retry

* go through all not-working @todo tests in src/test
	
* to support dynamic mixins we should use dynamic proxies to allow
	a groovy object to change metaclass at runtime

* groovy dynamic proxy of any Java object in Java-land?
	NullObject pattern
	
* immutable bean

* MetaClass.deriveMetaClass()
	MetaClass.addMixin(mixin)

* why does using the GroovyClassLoader cause the illegal access violation?

* constructors with map / tuple expressions, named parameter calling
 
* default values for parameters

* test try / catch with multiple exception types

* test [] on lists & maps?

* should we implement + and - for collections and maps?

	l = [1, 2] + [3, 4];
	assert l := [1, 2, 3, 4];
	
* should we implement get(String) on collection to implement nested property fetching?

* test use of overloaded setter methods & use of property notation
  so that the use of properties within a class should use setteres / getters.

* test the use of PropertyExpression
	a.b = c.d
	
* support static newInstance() method for constructors

* maybe split up ClassGenerator - do code gen & class gen separately

* mixin support...

	SomeClass.addMixin(Foo);
	
	MetaClass.addInterceptor( new Interceptor() {
		filter(method) {
			return method.isPublic();
		}
		invoke(method, args) {
			// do something
			method.invoke(args);
		}
	});

	* allow meta classes to be added dynamically using closure syntax?
	e.g. Map?
	
	
UI WORK
=======

* tree demo...

* when named method calls are supported with default values, refactor SwingBuilder
	so that all the creations of widgets occur with SwingFactory which would be 
	useful in and of itself
	- plus we should be using normal method call mechanism & for groovy to do the rest to avoid
	the long laborious Map coding
	
* add table layout cell spacing thingy

* FormModel.addPropertyModel(property)
	FormModel.addClosureModel(readClosure, writeClosure)

* ListModel is-a List but delegates to an underlying list and has events

* rename tableLayout -> table and table -> grid

* add sortableGrid

* create a GroovyUI
	-> interactive script + allows scripts to be run & objects explored

* groovy.model -> groovy.mvc?

* delete groovytablemodel / groovytablecolumn



ECLIPSE WORK
============

We really need to start work on the Eclipse plugin. I *so* want neat Eclipse support for groovy

* Run as JUnit support for Groovy! 

* Refactoring support for Groovy and tie it into the Java refactoring

* a WYSIWYG editor for Groovy. Though right now I've found that the Java Scrapbook editor is fine


JUNIT WORK
==========

* patch GroovyTestCase so that methods which return Object are included in the test. This avoids us having to
specify void for method return types.This requires a clever static method when we generate the
	bytecode which can instantiate a special kind of TestSuite
	unless there's another way?

OTHER STUFF
===========


OPTIMISATIONS
=============
* method invocations - if foo instanceof GroovyObject
then generate bytecode

foo.invokeMethod(method, args);

* could code generate the MetaClass with very efficient dynamic dispatch
	e.g. could switch() on the method name & then use real method invocation
	on the method instance


THINGS TO PONDER
================

* should we follow ruby rules where the last statement, if its an expression, then its an explicit return.

e.g.

foo() {
   2 * x
}

would implicitly mean

foo() {
   return 2 * x
}
