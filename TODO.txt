Core Groovy Tasks
=================

* GroovyAnt...
	an Ant builder

* to support dynamic mixins we should use dynamic proxies to allow
	a groovy object to change metaclass at runtime

* allow easy creation of sorting & Comparables via closures.

	comparable = new Sorter().orderBy{
		firstName(ascend:false)
		lastName(ignoreCase:true)
	}
	
	or using pure closures
	
	comparable = new Sorter(false) { i | i.lastName }
	
	
* groovy dynamic proxy of any Java object in Java-land?

* immutable bean

* make TestMixin which would allow...
	use to use a GroovyTestSuite to avoid the 'void' issue
	allow other naming conventions - endsWith("Test" || "Bug")
	allow a Groovy test to derive from *any* object!
	
	class FooTest extends Cheese mixin TestMixin {
		
		normalOperationTest() {
		}
		
		nullPointerBug() {
			...
		}
	}	

* expose AST of Closures so that GroovyDO can turn a filter into an SQL query if it wishes

* refactor to groovy.test + groovy.util?	

* DOM and SAX builders

* add the following symbols...
	class = current class
	super = parent class

* MetaClass.deriveMetaClass()
	MetaClass.addMixin(mixin)

* how could aspects & mixins merged together...

* why does using the GroovyClassLoader cause the illegal access violation?

* closure methods on Node
	
* more tests of field and property initialisers

* test closure with no argument, once bob's done the parser. both
    foo = { someMethod() }
    foo2 = {| someMethod() }
    foo.call()

* refactor the MetaClass to use an Object[] rather than Object for arguments?

* have some kinda way to do this

	MethodProxy proxy = metaClass.getMethod("name", List arguments)
	if (proxy != null) {
		proxy.call(instance, arguments);
	}
	else {
		// invoke on delegate
		InvokeHelper.invokeMethod(delegate, name, arguments)
	}	

	so rather than just doing 'hasMethod' or 'understandsMethod' we can return
	a Closure or MethodProxy or something or null if a method is not understood

* integer.times() method?

* validator for things like - undeclared variables

* closures need to be able to access properties of outer class

* closures - handle passing in of variables from outer scope?

* remove log4j dependency

* constructors with map / tuple expressions, named parameter calling
 
* default values for parameters

* test try / catch with multiple exception types

* test [] on lists & maps?

* constructors - test use of super()

* test use of method calls: foo() this.foo() class.foo() for local, inherited & global methods

* += and -= operators

* ++ and --

* should we implement + and - for collections and maps?

	l = [1, 2] + [3, 4];
	assert l := [1, 2, 3, 4];
	
* should we implement get(String) on collection to implement nested property fetching?

* while / do - while statements

* test use of overloaded setter methods & use of property notation
  so that the use of properties within a class should use setteres / getters.

* test the use of PropertyExpression
	a.b = c.d
	
* support static newInstance() method for constructors

* finish expression support in classgen

* support metadata (like JDK 1.5) as well as tree based metadata...

Ê Ê window = @layout {
Ê Ê Ê Ê frame text="My Window" size=[300,300] {
Ê Ê Ê Ê Ê Ê label text="Save changes?" bounds=[10,10,290,30]
Ê Ê Ê Ê Ê Ê panel bounds=[10,40,290,290] {
Ê Ê Ê Ê Ê Ê Ê Ê button text="OK" action={ save() ; window.close() }
Ê Ê Ê Ê Ê Ê Ê Ê button text="Cancel" action={ Êwindow.close() }
Ê Ê Ê Ê Ê Ê }
Ê Ê Ê Ê }
Ê Ê };

* maybe split up ClassGenerator - do code gen & class gen separately

* create MetaClass for JMX - so we can treat JMX objects as if they're normal objects

* mixin support...

	SomeClass.addMixin(Foo);
	
	MetaClass.addInterceptor( new Interceptor() {
		filter(method) {
			return method.isPublic();
		}
		invoke(method, args) {
			// do something
			method.invoke(args);
		}
	});

	* allow meta classes to be added dynamically using closure syntax?
	e.g. Map?
	
	

ECLIPSE WORK
============

We really need to start work on the Eclipse plugin. I *so* want neat Eclipse support for groovy

* Run as JUnit support for Groovy! 

* Refactoring support for Groovy and tie it into the Java refactoring

* a WYSIWYG editor for Groovy. Though right now I've found that the Java Scrapbook editor is fine


JUNIT WORK
==========

* patch GroovyTestCase so that methods which return Object are included in the test. This avoids us having to
specify void for method return types.This requires a clever static method when we generate the
	bytecode which can instantiate a special kind of TestSuite
	unless there's another way?

OTHER STUFF
===========


OPTIMISATIONS
=============
* method invocations - if foo instanceof GroovyObject
then generate bytecode

foo.invokeMethod(method, args);

* could code generate the MetaClass with very efficient dynamic dispatch
	e.g. could switch() on the method name & then use real method invocation
	on the method instance


THINGS TO PONDER
================

* should we follow ruby rules where the last statement, if its an expression, then its an explicit return.

e.g.

foo() {
   2 * x
}

would implicitly mean

foo() {
   return 2 * x
}
