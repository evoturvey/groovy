Core Groovy Tasks
=================

* AST for new object expressions, constructors with map / tuple expressions, named parameter calling
 
* default values for parameters

* test try / catch

* change to use == for equals?

* test [] on lists & maps?

* test use of method calls: foo() this.foo() class.foo() for local, inherited & global methods

* += and -= operators

* ++ and --

* this.foo should declare a local field?
	if so this could cause confusion with property access?
	maybe some new syntax like @foo or this->foo = x;
	

* should we implement + and - for collections and maps?

	l = [1, 2] + [3, 4];
	assert l := [1, 2, 3, 4];
	
* fix LocalPropertyTest

* should we implement get(String) on collection to implement nested property fetching?

* while / do - while statements

* test use of field & property initializers
 
* test use of overloaded setter methods & use of property notation
  so that the use of properties within a class should use setteres / getters.

* test the use of PropertyExpression
	a.b = c.d
	
* test use of invokeMethod(methodName, arguments) to test dynamic proxy features

* support static new() method for constructors

* finish expresssion support in classgen

* support metadata (like JDK 1.5) as well as tree based metadata...

Ê Ê window = @layout {
Ê Ê Ê Ê frame text="My Window" size=[300,300] {
Ê Ê Ê Ê Ê Ê label text="Save changes?" bounds=[10,10,290,30]
Ê Ê Ê Ê Ê Ê panel bounds=[10,40,290,290] {
Ê Ê Ê Ê Ê Ê Ê Ê button text="OK" action={ save() ; window.close() }
Ê Ê Ê Ê Ê Ê Ê Ê button text="Cancel" action={ Êwindow.close() }
Ê Ê Ê Ê Ê Ê }
Ê Ê Ê Ê }
Ê Ê };

* refactor ast into expression, statement packages

* maybe split up ClassGenerator - do code gen & class gen separately

* create static groovyMetaClass field in all groovy classes (& bytecode weave?)

* create MetaClass for JMX - so we can treat JMX objects as if they're normal objects

* mixin support...

	SomeClass.addMixin(Foo);
	
	MetaClass.addInterceptor( new Interceptor() {
		filter(method) {
			return method.isPublic();
		}
		invoke(method, args) {
			// do something
			method.invoke(args);
		}
	});

	* allow meta classes to be added dynamically using closure syntax?
	e.g. Map?
	
	

ECLIPSE WORK
============

We really need to start work on the Eclipse plugin. I *so* want neat Eclipse support for groovy

* Run as JUnit support for Groovy! 

* Refactoring support for Groovy and tie it into the Java refactoring

* a WYSIWYG editor for Groovy. Though right now I've found that the Java Scrapbook editor is fine


JUNIT WORK
==========

* patch GroovyTestCase so that methods which return Object are included in the test. This avoids us having to
specify void for method return types.


OTHER STUFF
===========


OPTIMISATIONS
=============
* method invocations - if instanceof DynamicMethodInvoke
then generate bytecode

foo.invokeMethod(method, args);

* for all Groovy classes we can autogenerate a _groovyMetaClass
static field which can be used to invoke methods & get properties.

class SomeGroovyClass {
	public static final MetaClass _groovyMetaClass = new MetaClass(thisClass);
}

someMethod() {
	foo = new SomeGroovyClass();
	foo.bar();
}

would translate to


someMethod() {
	foo = new SomeGroovyClass();
	SomeGroovyClass._groovyMetaClass.invokeMethod(foo, "bar", null);
}

* could code generate the MetaClass with very efficient dynamic dispatch
	e.g. could switch() on the method name & then use real method invocation
	on the method instance


LOGGING?
========

class Foo {

  private log;
  
  Foo(log = new GroovyLogger(thisClass)) {
    this.log = log;
  }
  
  foo(file) {
    log.aboutToOpenFile("opening file ${file});

    ..
    
    log.closedFile("closed down file ${file}");
  }
}

The above could call GroovyLogger.new(Class owner) which 
could then then have CommonsLogger(thisClass) implementation 
that can be switched in via registration or system property etc


MARKUP
======

Have Groovy -> SAX thingy for others to use as XML language?

A Groovy file could look like this & we could implement a Groovy SAX / DOM parser...

foo {
  bar {
    x(a:1, b:2) {
      c("hello");
      d(x:1, b:2);
    }
  }
}

For mixed text we could do

html {
  body {
    h1("this is title");
    
    p("blob of text");
    
    // mixed text
    p {
      xml.append("the ");
      b("quick");
      xml.append(" brown fox");
    }
    
    // element with attributes and text
    a(href:'http://blah', title:"foo") {
      xml.append("the text");
    }
    
    // though it'd be nicer like this
    a(href:'http://blah', title:"foo").append("the text");
  }
}  

Or even use lists....

    a(href:'http://blah', title:"foo") [
      "the text"
    ]
    
    p [
      "some text", b("this is bold"), "more text"
    ]
    
could also use nested expressions

	p("some text ${b('this is bold')} some text");

    

For something heavily namespaced we could do...

xsl = xmlns.namespace("http://foo");
xsl.template {
  xsl.element (match:"*") {
     foo = xmlns.namespace("whatnot");
     
     // lets use some namespaced attributes
     foo.bar(a:"123", b:5, xmlns:[foo.x:"abc", xsl.y:"abc"]) {
     	// i.e. for namespace prefixed attributes we use a map expression
     	// so that we can refer to namespace variables
     }
  }
}

If we supported named parameter calling...

class Foo extends MarkupBuilder {

  foo() {
    return html {
      tr(a : "hello");
      td(valign : "centre") {
  	    b("some text);
	    a(href : "http://blah", title : "whatnot") {
	      p("hello there");
	    };       
      };
      for i in [1, 2, 3] {
        td(valign: "right") {
          p("hello there ${i});
        }
      }
    };
  }
}

If we could remove the ; it'd be even cleaner
