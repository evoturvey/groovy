<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><title>Compiling Groovy Code</title></head>
<body>

<h1>Compiling Groovy</h1>

<p>
There are various options for compiling Groovy code and then either running it or
using the Java objects it creates in Java code.
</p>

<h2>Compling Groovy code to bytecode</h2>

<p>
There is an Ant task called <b>groovyc</b> which works pretty similarly to the <b>javac</b> Ant
task which takes a bunch of groovy source files and compiles them into Java bytecode. Each
groovy class then just becomes a normal Java class you can use inside your Java code if you wish.
Indeed the generated Java class is indistinguishable from a normal Java class, other than it
implements the <a href="apidocs/groovy/lang/GroovyObject.html">GroovyObject</a> interface.
</p>

<p>
The groovyc Ant task is implemented by the 
<a href="apidocs/org/codehaus/groovy/ant/Groovyc.html">Groovyc</a> class.
You can see an example of this in action inside Groovy's maven.xml file (just search for 'groovyc')
</p>

<h2>Dynamically loading and running Groovy code inside Java</h2>

<p>
Another option is to use a 
<a href="apidocs/groovy/lang/GroovyClassLoader.html">GroovyClassLoader</a> 
to load classes dynamically into a Java program and execute them (or use them) directly.
The following Java code shows an example...
</p>

<source>
ClassLoader parent = getClass().getClassLoader();
GroovyClassLoader loader = new GroovyClassLoader(parent);
Class groovyClass = loader.parse("Foo.groovy");

// lets call some method on an instance
GroovyObject groovyObject = (GroovyObject) groovyClass.newInstance();
Object[] args = {};
groovyObject.invokeMethod("run", args);
</source>

<h2>Runtime dependencies</h2>

<p>As well as the Groovy jar we also depend at runtime on</p>

<ul>
<li>asm</li>
</ul>

</body></html>