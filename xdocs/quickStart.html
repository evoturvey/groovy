<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><title>Groovy Quick Start Guide</title></head>
<body>

<h1>Quick Start Guide to Groovy</h1>

<p>
Groovy classes compile down to Java bytecode and so there's a 1-1 mapping between a Groovy class and a Java class.
Indeed each Groovy class can be used inside normal Java code - since it is a Java class too.
</p>

<p>
Probably the easiest way to get groovy is to try working with collections. In Groovy List (java.util.List) and Map (java.util.Map)
are both first class objects in the syntax. So to create a List of objects you can do the following...
</p>

<p>
Note that in the following snippets of Groovy code, the <i>groovy&gt;</i> means a command line prompt - you don't need to type this.
</p>

<source>
  groovy&gt; list = [1, 2, 'hello', new java.util.Date()]
  groovy&gt; list.size()
  4
  groovy&gt; list.get(2)
  'hello'
</source>

Notice that everything is an object (or that auto-boxing takes place when working with numbers). To create maps...

<source>
  groovy&gt; map = ['name':'James', 'location':'London']
  groovy&gt; map.size()
  2
  groovy&gt; map.get('name')
  'James'
</source>

Iterating over collections is easy...

<source>
  groovy&gt; list = [1, 2, 3]
  groovy&gt; for (i in list) { println(i) }
  1
  2
  3
</source>

Once you have some collections you can then use some of the new collection helper methods or try working with closures...


<h2>Working with closures</h2>

Closures are similar to Java's inner classes, except they are a single method which is invokable, with arbitrary parameters.
A closure can have as many parameters as you wish...

<source>
  groovy&gt; closure = { param | println("hello ${param}") }
  groovy&gt; closure.call("world!")
  hello world!
  groovy&gt; closure = { greeting, name | println(greeting + name) }
  groovy&gt; closure.call("hello ", "world!")
  hello world!
</source>

If no parameter(s) is(are) specified before the | symbol then a default named parameter, called 'it' can be used. e.g.

<source>
  groovy&gt; closure = { println("hello " + it) }
  groovy&gt; closure.call("world!")
  hello world!
</source>

Using closures allows us to process collections (arrays, maps, strings, files, SQL connections and so forth) in a clean way.

Here are a number of helper methods available on collections &amp; strings...

<h3>each</h3>

iterate via a closure

<source>
  groovy&gt;[1, 2, 3].each { item | print("${item}-" }
  1-2-3-
</source>

<h3>map</h3> 

convert values to new list using closure

<source>
  groovy&gt; [1, 2, 3].map { it * 2 }
  [2, 4, 6]
</source>

<h3>find</h3>

finds first item matching closure predicate
  
<source>
  groovy&gt; [1, 2, 3].find { it &gt; 1 }
  2
</source>

<h3>findAll</h3>

 finds all items matching closure predicate
  
<source>
  groovy&gt; [1, 2, 3].findAll { it &gt; 1 }
  [2, 3]
</source>

<h3>inject</h3>

<p>
 allows you to pass a value into the first iteration and then
 pass the result of that iteration into the next iteration and so
 on. This is ideal for counting and other forms of processing
</p>
  
<source>
  groovy&gt; [1, 2, 3].inject('counting: ') { str, item | str + item }
  "counting: 123"
  groovy&gt; [1, 2, 3].inject(0) { count, item | count + item }
  6
</source>


<p>
In addition there's 2 new methods for doing boolean logic on some collection...
</p>

<h3>every</h3>
 returns true if all items match the closure predicate

<source>
  groovy&gt; [1, 2, 3].every { it &lt; 5 }
  true
  groovy&gt; [1, 2, 3].every { item | item &lt; 3 }
  false
</source>

<h3>any</h3>
 returns true if any item match the closure predicate

<source>
  groovy&gt; [1, 2, 3].any { it &gt; 2 }
  true
  groovy&gt; [1, 2, 3].any { item | item &gt; 3 }
  false
</source>


Other helper methods include

<h3>max / min</h3>
 returns the max/min values of the collection - for Comparable objects

<source>
  groovy&gt; [9, 4, 2, 10, 5].max()
  10
  groovy&gt;   [9, 4, 2, 10, 5].min()
  2
  groovy&gt; ['x', 'y', 'a', 'z'].min()
  'a'
</source>

<h3>join</h3> concatenates the values of the collection together with a string value

<source>
  groovy&gt; [1, 2, 3].join('-')
  '1-2-3'
</source>


Also the 'yield' style of creating iterators, available in Python and
Ruby via the yield statement, is available. The only difference is
rather than using a yield statement, we're just using closures.

<source>
class Foo {
  myGenerator(Closure yield) {
    yield.call("A")
    yield.call("B")
    yield.call("C")
  }
}

foo = new Foo()
for (x in foo.myGenerator) {
  print("${x}-")
}
</source>

outputs
  A-B-C-

The use of Closure in the method prototype is optional. If we have
syntax sugar for invoking closures as if they are method calls, then
the generator method could look even more like the python/ruby
equivalent. Especially if parentheses are optional...
 
<source>
class Foo {
  myGenerator(yield) {
    yield "A"
    yield "B"
    yield("C") 
  }
}
</source>

</body></html>