<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head><title>Groovy Quick Start Guide</title></head>
<body>

<h1>Quick Start Guide to Groovy</h1>

<p>
Groovy classes compile down to Java bytecode and so there's a 1-1 mapping between a Groovy class and a Java class.
Indeed each Groovy class can be used inside normal Java code - since it is a Java class too.
</p>

<p>
Probably the easiest way to get groovy is to try working with collections. In Groovy List (java.util.List) and Map (java.util.Map)
are both first class objects in the syntax. So to create a List of objects you can do the following...
</p>

<source>
  &gt;&gt;&gt; list = [1, 2, 'hello', new Date()]
  &gt;&gt;&gt; list.size()
  4
  &gt;&gt;&gt; list.get(2)
  'hello'
</source>

Notice that everything is an object (or that auto-boxing takes place when working with numbers). To create maps...

<source>
  &gt;&gt;&gt; map = ['name':'James', 'location':'London']
  &gt;&gt;&gt; list.size()
  2
  &gt;&gt;&gt; map.get('name')
  'James'
</source>

Iterating over collections is easy...

<source>
  &gt;&gt;&gt; list = [1, 2, 3]
  &gt;&gt;&gt; for (i in list) { i.println() }
  1
  2
  3
</source>

Once you have some collections you can then use some of the new collection helper methods or try working with closures...


<h2>Working with closures</h2>

Closures are similar to Java's inner classes, except they are a single method which is invokable, with arbitrary parameters.
A closure can have as many parameters as you wish...

<source>
  &gt;&gt;&gt; closure = { param | System.out.println("hello " + param) }
  &gt;&gt;&gt; closure.call("world!")
  hello world!
  &gt;&gt;&gt; closure = { greeting, name | System.out.println(greeting + param) }
  &gt;&gt;&gt; closure.call("hello ", "world!")
  hello world!
</source>

If no parameter(s) is(are) specified before the | symbol then a default named parameter, called 'it' can be used. e.g.

<source>
  &gt;&gt;&gt; closure = { System.out.println("hello " + it) }
  &gt;&gt;&gt; closure.call("world!")
  hello world!
</source>

Using closures allows us to process collections (arrays, maps, strings, files, SQL connections and so forth) in a clean way.

Here are a number of helper methods available on collections &amp; strings...

<h3>each</h3>

iterate via a closure

<source>
  &gt;&gt;&gt;[1, 2, 3].each { item | item.print(); "-".print() }
  1-2-3
</source>

<h3>map</h3> 

convert values to new list using closure

<source>
  &gt;&gt;&gt; [1, 2, 3].map { it * 2 }
  [2, 4, 6]
</source>

<h3>find</h3>

finds first item matching closure predicate
  
<source>
  &gt;&gt;&gt; [1, 2, 3].find { it &gt; 1 }
  2
</source>

<h3>findAll</h3>

 finds all items matching closure predicate
  
<source>
  &gt;&gt;&gt; [1, 2, 3].findAll { it &gt; 1 }
  [2, 3]
</source>


In addition there's 2 new methods for doing boolean logic on some collection...

<h3>every</h3>
 returns true if all items match the closure predicate

<source>
  &gt;&gt;&gt; [1, 2, 3].every { it &lt; 5 }
  true
  &gt;&gt;&gt; [1, 2, 3].every { item | item &lt; 3 }
  false
</source>

<h3>any</h3>
 returns true if any item match the closure predicate

<source>
  &gt;&gt;&gt; [1, 2, 3].every { it &gt; 2 }
  true
  &gt;&gt;&gt; [1, 2, 3].every { item | item &gt; 3 }
  false
</source>


Other helper methods include

<h3>max / min</h3>
 returns the max/min values of the collection - for Comparable objects

<source>
  &gt;&gt;&gt; [9, 4, 2, 10, 5].max()
  10
  &gt;&gt;&gt;   [9, 4, 2, 10, 5].min()
  2
  &gt;&gt;&gt; ['x', 'y', 'a', 'z'].min()
  'a'
</source>

<h3>join</h3> concatenates the values of the collection together with a string value

<source>
  &gt;&gt;&gt; [1, 2, 3].join('-')
  '1-2-3'
</source>


Also the 'yield' style of creating iterators, available in Python and
Ruby via the yield statement, is available. The only difference is
rather than using a yield statement, we're just using closures.

<source>
class Foo {
  myGenerator(Closure yield) {
  yield.call("A")
  yield.call("B")
  yield.call("C")
  }
}

foo = new Foo()
for (x in foo.myGenerator) {
  x.print(); "-".print()
}
</source>

outputs
  A-B-C

The use of Closure in the method prototype is optional. If we have
syntax sugar for invoking closures as if they are method calls, then
the generator method could look even more like the python/ruby
equivalent. Especially if parentheses are optional...
 
<source>
class Foo {
  myGenerator(yield) {
  yield "A"
  yield "B"
  yield("C") 
  }
}
</source>

</body></html>