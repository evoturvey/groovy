
1 Statements

Groovy uses a similar syntax to Java although in Groovy semicolons are optional. 
This saves a little typing but also makes code look much cleaner (surprisingly so for such
a minor change). So normally if one statement is on each line you can ommit semicolons
altogether - though its no problem to use them if you want to. If you want to put multiple statements on a line
use a semicolon to separate the statements.

{code:groovy}
x = [1, 2, 3]
println(x)
y = 5; x = y + 7
println(x)
assert x == 12
{code}

If the end of the line is reached and the current statement is not yet complete
it can be spanned across multiple lines. So for things like method parameters
or creating lists or for complex if expressions you can span multiple lines.

{code:groovy}
x = [1, 2, 3,
	4, 5, 6]
println(
	x
)
if (x != null && 
	x.size() > 5) {
	println("Works!")
}
else {
	assert false: "should never happen ${x}"
}
{code}


1.1 Method calls

Method calling syntax is similar to Java where methods can be called on an object (using dot) or
a method on the current class can be called. Static and instance methods are supported.

{code:groovysh}
class Foo {
	calculatePrice() {
		1.23
	}
	
	static void main(args) {
		foo = new Foo()
		p = foo.calculatePrice()
		assert p > 0
		
		println "Found price: " + p
	}
}
{code}

Notice that the ~~return~~ statement is optional at the end of methods. 
Also you don't need to specify a return type (it will default to Object in the bytecode
if none is specified).

1.1 Optional parenthesis

Method calls in Groovy can ommit the parenthesis if there is at least one 
parameter and there is no ambiguity.

{code:groovysh}
println "Hello world"
System.out.println "Nice cheese Gromit!"
{code}

1.1 Named parameter passing 

When calling a method you can pass in named parameters. Parameter
names and values are separated by a colon (like the Map syntax)
though the parameter names are identifiers rather than Strings.

Currently this kind of method passing is only implemented for calling methods which take a Map or
for constructing JavaBeans. 

{code:groovysh}
bean = new Expando(name:"James", location:"London", id:123)
println "Hey " + bean.name
assert bean.id == 123
{code}

Please refer to {link:GroovyMarkup|markup.html} for more examples

1.1 Passing closures into methods

Closures are described in more detail {link:here|closures.html}. Closures can
be passed into methods like any other object

{code:groovysh}
closure = { param | param + 1 }
answer = [1, 2].collect(closure)
assert answer == [2, 3]
{code}

Though there is some syntax sugar to make calling methods which take a closure easier.
Instead of specifying parenthesis, you can just specify a closure. e.g.

{code:groovysh}
answer = [1, 2].collect { param | param + 1 }
assert answer == [2, 3]
{code}

The above code is equivalent to the previous code, just a little more groovy.
If a method takes parameters you can leave the closure outside of the parenthesis
(provided that the closure parameter is the last parameter on the underlying method).

{code:groovysh}
value = [1, 2, 3].inject(0) { count, item | count + item }
assert value == 6
{code}

The above code is equivlanent to the following (but just neater)

{code:groovysh}
value = [1, 2, 3].inject(0, { count, item | count + item })
assert value == 6
{code}

1.1. Important Note
Note that when using the neater syntax for specifying closures either without parenthesis or
by specifying the closure after the parenthesis, the closure must start on the same line.
i.e. the { symbol must be on the same line as the method call statement. Otherwise the parser
interprets the { as a start of a block.


1.1 Dynamic method dispatch

If a variable is not constrained by a type then dynamic method dispatch is used. This is 
often referred to as ~~dynamic typing~~ whereas Java uses ~~static typing~~ by default.

You can mix and match both dynamic and static typing in your code by just adding or removing
types. e.g.

{code:groovysh}
dynamicObject = "hello world".replaceAll("world", "Gromit")
dynamicObject += "!"
assert dynamicObject == "hello Gromit!"

String staticObject = "hello there"
staticObject += "!"
assert staticObject == "hello there!"
{code}

1.1 Properties

These are described in more detail in the {link:GroovyBeans|beans.html} section.

To access properties you use dot with the property name. e.g.

{code:groovysh}
bean = new Expando(name:"James", location:"London", id:123)
name = bean.name
println("Hey ${name}")
bean.location = "Vegas"
println bean.name + " is now in " + bean.location
assert bean.location == "Vegas"
{code}


1.1 Safe navigation

If you are walking a complex object graph and don't want to have NullPointerExceptions thrown
you can use the -> operator rather than . to perform your navigation.

{code:groovysh}
foo = null
bar = foo->something->myMethod()
assert bar == null
{code}
